---
title: 函数扩展
date: 2025-09-27
tags: ["javascript", "函数", "ES6"]
excerpt: "ES6函数扩展"
---

## 函数扩展

### 函数参数的扩展

#### 默认参数

基本用法

```javascript
function fn(name, age = 17) {
    console.log(name + "," + age)
}

fn("Amy", 18)
fn("Amy", "")
fn("Amy")
```

控制台输出

```console
Amy,18
Amy,
Amy,17
```

**注意**&nbsp;&nbsp;&nbsp;&nbsp;使用函数默认参数时，不允许有同名参数。

在普通模式下使用同名参数

```javascript
function fn(name, name) {
    console.log(name)
}

fn("Bob", "Mike")
```

控制台输出

```console
Mike
```

前面的参数会被后面的同名参数覆盖掉。

如果使用严格模式

```javascript
"use strict"
function fn(name, name) { 
    console.log(name)
}
```

此时会打印错误信息

```console
Uncaught SyntaxError SyntaxError: Duplicate parameter name not allowed in this context
```

使用函数默认参数时会自动启用严格模式

```javascript
function fn(name,name,age=17){
 console.log(name + "," + age)
}
```

此时控制台会打印错误信息

```console
Uncaught SyntaxError SyntaxError: Duplicate parameter name not allowed in this context
```

只有在未传递参数，或者参数为`undefined`时，才会使用默认参数，`null`值被认为是有效的值传递。

```javascript
function fn(name, age = 17) {
    console.log(name + "," + age)
}

fn("Amy", null)
fn("Amy", undefined)
```

控制台输出

```console
Amy,null
Amy,17
```

函数参数默认值存在**暂时性死区**（Temporal Dead Zone, TDZ），在函数参数默认值表达式中，还未初始化赋值的参数值无法作为其他参数的默认值。

```javascript
function f(x, y = x) {
    console.log(x, y)
}

f(1)
```

执行过程

```text
调用f(1)，参数开始初始化------→x被赋值为1------→y的默认值表达式y = x执行，此时x已经初始化完成------→y获得值1
```

那么结果正常，函数输出结果

```console
1 1
```

如果调用函数的时候没有进行初始化

```javascript
function f(x = y) {
    console.log(x)
}

f()
```

执行过程

```text
调用f(1)，参数开始初始化------→x默认值表达式x = y执行------→在表达式中尝试访问y，但此时y还没被初始化-----→-y处于暂时性死区，无法访问
```

打印错误信息

```console
Uncaught ReferenceError ReferenceError: y is not defined
```

#### 不定参数

不定参数（Rest Parameters）语法允许我们将一个不定数量的参数表示为一个**数组**(可以使用数组的方法)。
用来表示不确定参数个数，形如，`...` + 变量名，由`...`加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。

基本用法

```javascript
function f(...values) {
    console.log(values.length)
}

f(1, 2)
f(1, 2, 3, 4)
```

控制台输出

```console
2
4
```

### 箭头函数

ES6允许使用户箭头（`=>`）定义函数，箭头函数提供了一种更加简洁的函数书写方式。

箭头函数的基本语法

```javascript
参数 => 函数体
```

使用赋值的形式（函数表达式）声明函数

```javascript
const add = function (x, y) {
    return x + y
}
```

等同于

```javascript
const add = (x, y) => x + y
```

调用函数

```javascript
add(1, 2)
```

返回值为

```text
3
```

当箭头函数函数体有多行语句时，用`{}`包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略`{}`, 结果会自动返回。

```javascript
const getCircleArea = r => {
    const PI = 3.14
    return PI * r * r
}
```

当箭头函数要返回对象的时候，为了区分于代码块，要用`()`将对象包裹起来

错误写法

```javascript
const getUser = (name, id) => {
    id: id,
    name: name
}
```

箭头函数将`{}`识别成了函数体而不是对象，所以报错

```console
Uncaught SyntaxError SyntaxError: Unexpected token ':'
```

正确写法

```javascript
const getUser = (name, id) => ({
    id: id,
    name: name
})
```

箭头函数没有`this`、`arguments`和`new.target`绑定。

对于普通函数来说，内部的`this`指向函数运行时所在的对象，而箭头函数内部的`this`就是定义时上层作用域中的`this`。

普通函数

```javascript
window.name = "Mike"
const user = {
    name: "Bob",
    age: 20,
    getName() {
        console.log(this.name)
    }
}

user.getName()
```

控制台打印的是`user`内部的属性`name`

```console
Bob
```

箭头函数

```javascript
window.name = "Mike"
const user = {
    name: "Bob",
    age: 20,
    getName: () => {
        console.log(this.name)
    }
}

user.getName()
```

这个箭头函数定义在全局作用域中（因为对象字面量不创建新的作用域），所以它的`this`指向全局对象（浏览器中全局对象是`window`）。

所以上面箭头函数输出结果为

```console
Mike
```

对于普通函数来说`arguments`参数是一个类数组对象，包含了所有传入函数的参数。箭头函数没有这个属性。如果想要实现类似的功能可以使用Rest参数（`...`）进行替代。

```javascript
const example = (...args) => {
    console.log("所有参数:", args)
    console.log("参数个数:", args.length)
    console.log("第一个参数:", args[0])
}

example(1, 2, 3, 4)
```

控制台输出

```console
所有参数: [1, 2, 3, 4]
参数个数: 4
第一个参数: 1
```
