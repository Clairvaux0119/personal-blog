---
title: 对象扩展
date: 2025-09-25
tags: ["javascript", "对象", "ES6"]
excerpt: "ES6对象扩展与新增方法"
---

## 对象扩展

### 属性的简洁表示法

ES6允许在大括号里面直接写入变量和函数作为对象的属性和方法。这样的书写更加简洁。

```javascript
let name = "Bob"
const user = {
    name,
    age: 20
}
```

除了属性简写，方法也可以简写

```javascript
const object = {
    method() {
        return "Hello!"
    }
}
```

等同于

```javascript
const object = {
    method: function () {
        return "Hello!"
    }
}
```

### 属性名表达式

ES6允许字面量定义对象时，用表达式作为对象的属性名，即把表达式放在方括号内。

```javascript
const obj = {
    ["he" + "llo"]() {
        return "Hi"
    }
}
console.log(obj.hello())
```

控制台输出

```console
Hi
```

也可以用变量作为表达式

```javascript
let names = "user1"
const user = {
    [names]: "Bob",
    age: 20
}

console.log(user)
```

控制台输出

```console
{user1: 'Bob', age: 20}
```

要注意的是，属性的简洁表示法和属性名表达式不能同时使用，否则会报错。

```javascript
const hello= "Hello"
const object1= {
    [hello]
}
console.log(object1)

const object2 = {
    [hello + "2"]: "world"
}
console.log(object2)
```

对于`object1`，控制台打印错误信息

```console
Uncaught SyntaxError SyntaxError: Unexpected token '['
```

对于`object2`，控制台输出

```console
{Hello2: 'world'}
```

### 对象的扩展运算符

ES2018将扩展运算符（`...`）引入到对象中，它用于取出参数对象所有可遍历属性然后拷贝到当前对象。

基本用法

```javascript
let user = {
    name: "Bob",
    age: 20
}
let someone = { ...user }
console.log(someone)
```

控制台输出

```console
{name: 'Bob', age: 20}
```

使用扩展运算符，可以简便地实现对象合并。

```javascript
let name = { name: "Bob" }
let age = { age: 20 }
let user = { ...name, ...age }

console.log(user)
```

控制台输出

```console
{name: 'Bob', age: 20}
```

#### 注意事项

自定义的属性和扩展运算符对象里面属性的相同的时候：**自定义的属性在拓展运算符后面，则拓展运算符对象内部同名的属性将被覆盖掉。**

```javascript
let user = {
    name: "Bob",
    age: 20
}
let someone = { ...user, name: "Mike" }

console.log(someone)
```

控制台输出

```console
{name: 'Mike', age: 20}
```

自定义的属性在扩展运算符前面，则变成设置新对象默认属性值。

```javascript
let user = {
    name: "Bob",
    age: 20
}
let someone = { name: "Mike", age: 18, ...user}

console.log(someone)
```

控制台输出

```console
{name: 'Bob', age: 20}
```

### 对象新增方法

#### `Object.assign()`

`Object.assign()`用于将源对象的所有可枚举属性复制到目标对象中。

语法

```javascript
Object.assign(target, source1, source2, ..., sourceN)
```

基本用法

```javascript
let target = { a: 1 }
let object2 = { b: 2 }
let object3 = { c: 3 }
Object.assign(target, object2, object3) 
```

其中第一个参数是目标对象，后面的参数是源对象。此时`target`的值为

```javascript
{a: 1, b: 2, c: 3}
```

如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。

```javascript
let target = { a: 1 }
let object2 = { b: 2 }
let object3 = { c: 3 }
let object4 = { c: 4 }
Object.assign(target, object2, object3, object4) 
```

`object3`和`object4`对象有同名属性`c`，那么后面`object4`的属性会覆盖`object3`的属性，此时`taget`的值为

```javascript
{a: 1, b: 2, c: 4}
```

如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。

当参数不是对象时

```javascript
Object.assign(3)
```

会返回

```console
Number {3}
```

数字3被包装成了一个`Number`对象，这种情况通常无意义，不建议使用。

当参数为`null`或`undefined`时，因为`null`和`undefined`不能转化为对象，所以会报错。

```javascript
Object.assign(null)
Object.assign(undefined)
```

控制台打印错误信息

```console
Uncaught TypeError TypeError: Cannot convert undefined or null to object
```

当参数不止一个时，`null`和`undefined`不放第一个，即不为目标对象时，会跳过`null`和`undefined`，不报错。

```javascript
Object.assign(1, undefined)
Object.assign({ a: 1 }, null)
Object.assign(undefined, { a: 1 })
```

在控制台分别输出上述代码的值为

```console
Number {1}
{a: 1}
Uncaught TypeError TypeError: Cannot convert undefined or null to object
```

要注意的是，`assign`的属性拷贝是浅拷贝。

**浅拷贝**是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。

#### Object.is()

用来比较两个值是否严格相等，与（`===`）基本类似。

语法

```javascript
Object.is(value1, value2)
```

基本用法

```javascript
Object.is("q", "q")
Object.is(1, 1)
Object.is([1], [1])
Object.is({ q: 1 }, { q: 1 })
```

几个表达式的值分别为

```javascript
true
true
false
false
```

`Object.is([1], [1])`的值为`false`的原因是这个表达式等同于下面

```javascript
const arr1 = [1]
const arr2 = [1]
Object.is(arr1, arr2) 
```

每次使用数组字面量`[]`都会创建一个**新的数组对象**，即使内容相同，它们也是不同的对象引用。

而`Object.is({ q: 1 }, { q: 1 })`的值为`false`的原因与数组字面量`[]`类似，上述表达式等同于下面

```javascript
const obj1 = { q: 1 }
const obj2 = { q: 1 }
Object.is(obj1, obj2)
```

每次使用对象字面量`{}`都会创建一个**新的对象**，即使属性相同，它们也是不同的对象引用。

与（`===`）的区别

`Object.is(+0, -0)`和`Object.is(NaN, NaN)`的值均为`true`，而`+0 === -0`和`NaN === NaN`的值均为`false`。
