---
title: 防抖
date: 2025-09-17
tags: ["javascript", "防抖"]
excerpt: "防抖的知识以及相关处理方法"
---

## 防抖

防抖 (debounce) 严格算起来属于性能优化的知识，但实际上遇到的频率相当高，处理不当或者放任不管容易引起浏览器卡死。

给定一个滚动条监视的例子

```javascript
function scrollHandle() {
    let scrollTop = document.documentElement.scrollTop
    console.log("滚动条位置", scrollTop)
}

window.onscroll = scrollHandle
```

在运行之后会发现，这个函数的执行频率太高了。当点击一次键盘的向下方向键，这个函数执行了9次。

```console
滚动条位置 1.600000023841858
滚动条位置 4.800000190734863
滚动条位置 10.399999618530273
滚动条位置 17.600000381469727
滚动条位置 24.799999237060547
滚动条位置 32
滚动条位置 36.79999923706055
滚动条位置 39.20000076293945
滚动条位置 40
```

实际上我们不并需要这样高频的反馈，毕竟浏览器的性能是有限的，不应该浪费在这里。下面讨论如何优化这种场景。

在第一次触发事件时，不立即执行函数，而是给出一个期限值（比如200ms），然后

+ 如果在200ms内没有再次触发滚动事件，那么执行函数。

+ 如果在200ms内再次触发滚动事件，当前计时取消，重新开始计时。

效果：短时间内大量触发同一事件只会执行一次函数。

下面尝试实现这种思路

```javascript
function debounce(fn, delay) {
    let timer = null

    // 闭包
    return function () {
        clearTimeout(timer)
        timer = setTimeout(fn, delay)
    }
}

function scrollHandle() {
    let scrollTop = document.documentElement.scrollTop
    console.log("滚动条位置", scrollTop)
}

window.addEventListener('scroll', debounce(scrollHandle, 200))
```

运行之后滑动进度条控制台输出频率变低，实现了**防抖**。

>**防抖定义**
>
>对于短时间内连续触发的事件（比如上述代码的滚动事件），防抖的含义就是让某个事件期限（比如上述代码的200ms）内，事件处理函数只执行一次。
